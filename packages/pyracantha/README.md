# Pyracantha

 > Red / green syntax trees for Typescript

Pyracantha is a lightweight library aimed at providing an abstract red / green
syntax tree which can be used as the output of error tolerant parsers. Trees
are split into two layers: green - which represents abstract syntax items, and
red - which represents specific pieces of syntax in a document including
position information.

The aim of this abstraction is to share allocation of similar pieces of syntax
amongst many red nodes by re-using the underlying green node. Red nodes are
also fabricated on-demand so you only pay for the parts of the tree which you
traverse.

## Syntax Kinds

Each node or token in the tree has a `SyntaxKind` attached to it. As far as
Pyracantha is concerned this is an opaque number. It is up to a higher level
syntax wrapper in consumers to impose meaning on these kinds.

A common pattern is to define distinct ranges of kinds for nodes, tokens, and
a unique kind for error nodes. When printing a tree using the `Debug.debugDump`
API a `KindFormatter` can be provided to allow replace these opaque kinds in
debug output with user-recogniseable ones.

## The Tree Builder

Syntax trees can be built from the ground up using the `GreenNode` and
`GreenToken` constructors. For ergonomics however trees produced by a parser
should use the `GreenTreeBuilder`. This object allows a tree to be built
bit-by-bit using the `startNode()`, `finishNode()`, and `token()` methods.

```typescript
// The builder allows nodes to be incrementally constructed
const builder = new GreenTreeBuilder();
builder.startNode(SyntaxKinds.BINARY_EXPRESSION);
builder.token(SyntaxKinds.NUMBER, "1");
builder.token(SyntaxKinds.OPERATOR, "+");
builder.token(SyntaxKinds.NUMBER, "1");

// A tree can be generated by finalising the builder
const tree = builder.buildRoot(SyntaxKinds.PROGRAM);
```

In addition to the basic build API a 'mark' based API is available to allow for
speculative parsing, and re-parenting of nodes.

For speculative parsing of nodes a `Mark` is first created, and later *applied*
using the `applyMark()` function to retroactively start a node at the marked
position:

```typescript
const builder = new GreenTreeBuilder();
// Here we don't know if this is a 'lone' identifier, or a call expression so
// we create a mark.
const mark = builder.mark();
builder.Token(SyntaxKinds.IDENTIFIER);
builder.Token(SyntaxKinds.PAREN, "(");
builder.Token(SyntaxKinds.PAREN, ")");

// Now we know this is a call expression mark will wrap it in a `CALL` node
builder.applyMark(mark, SyntaxKinds.CALL)
```

The mark API also allows parsing to be backtracked using the `sliceOffMark()`
and `elements()` functions. An alternative implementation of the above:

```typescript
const builder = new GreenTreeBuilder();

// store a reference to this point so we can backtrack if needed.
const mark = builder.mark();

builder.Token(SyntaxKinds.IDENTIFIER);
// we now know we are looking at a `(`, backtrack and start the call node
const nodePart = builder.sliceOffMark(mark);
builder.startNode(SyntaxKinds.CALL);

// Splice the part built-node back in
builder.elements(nodePart);

// and continue as if we had always started the CALL node correctly.
builder.Token(SyntaxKinds.PAREN, "(");
builder.Token(SyntaxKinds.PAREN, ")");
builder.finishNode();
```

## The Red Tree

Once a green tree has been created it can be turned into a fully-fledged red
tree with the `RedNode.createRoot()` function. This returns a new red tree
wrapping the given green node with an offset of `0`. Red trees are lightweight
wrappers over the green tree with a `range` on each node which tracks the
absolute position within the document. The tree at a given red node can
be traversed with the `children()`, `childrenWithTokens()`, and
`childrenOfKind()` functions.

## Walking

To traverse a tree without consuming unbounded stack space a `Walk.walk()`
function is provided. This calls back to a given `TreeWalker` implementation
when each node is entered, on each token, and when the node is left.

## Debug Output

Using the `walk` API `Debug.debugDump()` and `Debug.debugToString()` allow a
quick representation of a tree to be dumped to console, or a `string`. Both
accept a `KindFormatter` to pretty-print the opaque `SyntaxKind`. If using an
`enum` to represent kinds then indexing into the enum can be used for this:

```typescript
export enum SyntaxKinds {
  Error = -1,

  // NODES
  Program = 1
  Operator = 2,

  // TOKENS
  Number = 100,
  Identifier = 101
}

// dump with pretty-printed kinds
debugDump(root, (k) => SyntaxKinds[k]);

// Program: {0..3}
//   Number: {0..1} "1"
//   Operator: {1..2} "+"
//   Identifier: {2..3} "a"
```

## Prior Art

Pyracantha is a derivative of the [`Firethorn` library][firethorn], itself based
on [`Rowan`][rowan]. For a more detailed discussion of red-green trees see
[*Red Green Syntax Trees - an Overview*][blog-overview], and
[*Syntax in rust-analyzer*][ra-syntax].

 [firethorn]: https://github.com/iwillspeak/Firethorn
 [rowan]: https://github.com/rust-analyzer/rowan
 [blog-overview]: https://willspeak.me/2021/11/24/red-green-syntax-trees-an-overview.html
 [ra-syntax]: https://github.com/rust-lang/rust-analyzer/blob/master/docs/dev/syntax.md